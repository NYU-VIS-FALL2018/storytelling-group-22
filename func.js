let tracts;
let numberByCT;
let numberBySpecies;
let popularSpcByCT;

green = "rgb(20, 108, 54)";
yellow = "rgb(244, 209, 102)";
// Set an array of colors from yellow to green
colorRange = d3.scaleLinear()
    .domain([0, 100])
    .range([yellow, green]);

// Leave tract whose record is not found to be gray
undefinedColor = "#ddd";

strokeColor = "#444";

/*top10Colors = d3.schemeCategory10.map(a => {
    result = d3.hsl(a);
    result.s *= 0.8;
    return result.brighter(0.5);
});*/

// generated by http://vrl.cs.brown.edu/color
top10Colors = ["rgb(221,221,221)", "rgb(236,127,106)", "rgb(46,229,45)", "rgb(143,138,197)", "rgb(47,209,146)", "rgb(171,138,119)", "rgb(35,158,179)", "rgb(197,223,114)", "rgb(242,75,199)", "rgb(243,192,17)", "rgb(123,155,71)"]
top10Colors.forEach((color, i, colors) => {
    color = d3.hsl(color);
    color.s *= 0.8;
    colors[i] = color.brighter(0.4);
})

function total(record) {
    return parseInt(record.Fair) + parseInt(record.Good) + parseInt(record.Poor);
}

function getSpeciesIndex(species, top10Species) {
    if (species === undefined || top10Species.indexOf(species) == -1) {
        return -1;
    }
    return top10Species.indexOf(species);
}

function getSpeciesColor(index) {
    return top10Colors[index + 1];
}

function highlightColorInSpecies(d, index, barsOnly=false) {
    if (index < 0) {
        return;
    }
    setColorInSpecies(d, true, barsOnly);
    setColorInOneSpecies(index, getSpeciesColor(index), barsOnly);
}

function setColorInSpecies(d, highlight=false, barsOnly=false) {
    for (i = -1; i < 10; i++) {
        color = getSpeciesColor(i);
        if (highlight) {
            color = d3.hsl(color);
            color.opacity = 0.2;
            color.s *= 0.5;
        }
        setColorInOneSpecies(i, color, barsOnly);
    }
}

function setColorInOneSpecies(index, color, barsOnly=false) {
    d3.select("#species").select("rect.species" + index)
        .attr("fill", color);
    if (!barsOnly) {
        d3.select("#species").selectAll("path.species" + index)
            .attr("fill", color);
    }
}

function setColorInBars(d, i, paths, highlight) {
    index = Number(paths[i].classList.value.substr(7));
    if (index < 0) {
        return;
    }
    setColorInSpecies(d, highlight, true);
    color = getSpeciesColor(index);
    if (highlight) {
        color = d3.color(color).brighter(0.5);
    }
    setColorInOneSpecies(index, color, true);
    paths[i].attributes.fill.value = color;
}

function loadData(dir) {
    return Promise.all([
        d3.json(`${dir}tracts.geo.json`),
        d3.csv(`${dir}num_by_ct.csv`),
        d3.csv(`${dir}num_by_spc.csv`),
        d3.csv(`${dir}pop_by_ct.csv`)
    ]).then(datasets => {
        tracts = datasets[0];
        numberByCT = datasets[1];
        numberBySpecies = datasets[2];
        popularSpcByCT = datasets[3];
    });
}

function showData() {
    container = d3.select("#count");
    width = container.node().getBoundingClientRect().width;
    height = container.node().getBoundingClientRect().height;
    margin = {
        top: 10,
        bottom: 30,
        left: 70,
        right: 10
    };
    bodyHeight = height - margin.top - margin.bottom;
    bodyWidth = width - margin.left - margin.right;
    boroName = ["0", "Manhattan", "Bronx", "Brooklyn", "Queens", "Staten Island"];
    boroCount = [0, 0, 0, 0, 0, 0];
    
    
    numberByCT.forEach(a => {
        // The first digit is borough numeric code
        boroCount[a.boro_ct[0]] += total(a);
    });
    xScale = d3.scaleBand()
        .range([0, bodyWidth])
        .domain(boroName.slice(1))
        .padding(0.1);
    yScale = d3.scaleLinear()
        .range([bodyHeight, 0])
        .domain([0, d3.max(boroCount)]);
    container.append("g")
        .style("transform", `translate(${margin.left}px, ${margin.top}px)`)
        .selectAll(".bar")
        .data(boroCount.slice(1))
        // Adding a rect tag for each borough
        .enter().append("rect")
        .attr("y", d => yScale(d))
        .attr("height", d => yScale(0) - yScale(d))
        .attr("x", (d, i) => xScale(boroName[i + 1]))
        .attr("width", xScale.bandwidth())
        .attr("fill", colorRange(80));
    container.append("g")
        .style("transform", `translate(${margin.left}px, ${height - margin.bottom}px)`)
        .call(d3.axisBottom(xScale).ticks(5));
    container.append("g")
        .style("transform", `translate(${margin.left}px, ${margin.top}px)`)
        .call(d3.axisLeft(yScale));
    // Insert the sum into HTML
    document.getElementById("sum").innerHTML = d3.sum(boroCount).toLocaleString();
    
    
    container = d3.select("#density");
    width = container.node().getBoundingClientRect().width;
    height = container.node().getBoundingClientRect().height;
    projection = d3.geoMercator();
    projection.scale(height * 100)
        .center([-73.98, 40.707])
        .translate([width / 2, height / 2]);
    path = d3.geoPath(projection);
    
    container.selectAll("path").data(tracts.features)
        .enter().append("path")
        .attr("d", path) // Use the path generator to draw each tract
        .attr("stroke", strokeColor)
        .attr("stroke-width", height / 2500)
        .attr("fill", d => {
            // Find the record of this tract
            numberByCTRow = numberByCT.find(e => e.boro_ct == d.properties.boro_ct2010);
            // If not found, leave it gray
            if (numberByCTRow === undefined) {
                return undefinedColor;
            }
            number = total(numberByCTRow);
            density = number / parseFloat(d.properties.shape_area);
            // Set color accoring to the density
            // The min to show is 0.000015
            if (density < 0.000015) {
                return colorRange(0);
            }
            // The max of density is 0.000265
            // A 0.75 exponent is set so that there will be more green (data near 1)
            return colorRange(Math.floor(Math.pow((density - 0.000015) / 0.000265, 0.75)  * 100));
        })
    
    
    container = d3.select("#species");
    width = container.node().getBoundingClientRect().width;
    height = container.node().getBoundingClientRect().height;
    projection = d3.geoMercator();
    projection.scale(height * 100)
        .center([-73.98, 40.707])
        .translate([width / 2, height / 2]);
    path = d3.geoPath(projection);
    margin.left = 120;
    margin.top = 40;
    bodyWidth = 400;
    numberBySpecies.sort((a, b) => total(b) - total(a));
    // Display top 10 species only
    top10 = numberBySpecies.slice(0, 10);
    // Covert to a list of species
    top10Species = top10.map(a => a.spc_common);
    xScale = d3.scaleLinear()
        .range([0, bodyWidth])
        // Max of count 
        .domain([0, total(top10[0])]);
    yScale = d3.scaleBand()
        .range([0, bodyHeight])
        .domain(top10Species);
    container.append("g")
        .style("transform", `translate(${margin.left}px, ${margin.top}px)`)
        .selectAll(".bar")
        .data(top10)
        // Adding a rect tag for each species
        .enter().append("rect")
        .attr("height", yScale.bandwidth())
        .attr("y", d => yScale(d.spc_common))
        .attr("width", d => xScale(total(d)))
        .attr("stroke", "none")
        .attr("stroke-width", 4)
        .attr("class", (d, i) => "species" + i)
        // Register mouse over and out events
        .on("mouseover", (d, i) => highlightColorInSpecies(d, i))
        .on("mouseout", d => setColorInSpecies(d));
    container.append("g")
        .style("transform", `translate(${margin.left}px, ${margin.top}px)`)
        .call(d3.axisTop(xScale).ticks(5));
    container.append("g")
        .attr("class", "yScale")
        .style("transform", `translate(${margin.left}px, ${margin.top}px)`)
        .call(d3.axisLeft(yScale));
    container.select(".yScale").selectAll("text")
        .attr("onclick", (d, i) => `onclick="showIntro(${i})"`)
        .attr("cursor", "pointer");
    
    container.selectAll("path").data(tracts.features)
        .enter().append("path")
        .attr("d", path) // Use the path generator to draw each tract
        .attr("stroke", strokeColor)
        .attr("stroke-width", height / 2500)
        .attr("class", d => {
            // Find the record of this tract
            popularSpcByCTRow = popularSpcByCT.find(e => e.boro_ct2010 == d.properties.boro_ct2010);
            if (popularSpcByCTRow === undefined) {
                index = -1;
            } else {
                index = getSpeciesIndex(popularSpcByCTRow.species, top10Species);
            }
            //console.log(index)
            return "species" + index;
        })
        .on("mouseover", (d, i, paths) => setColorInBars(d, i, paths, true))
        .on("mouseout", (d, i, paths) => setColorInBars(d, i, paths, false));
    
    setColorInSpecies();
    
    // Formalize each line in species intro
    titles = ["Binomial Name", "Name in Chinese", null, "Date", "Tree ID", "Address", "Trunk Diameter"]
    for (i = 0; i < 10; i++) {
        d = document.getElementById("species" + i);
        ps = document.getElementById("species" + i).getElementsByTagName("p");
        if (ps.length < titles.length) {
            continue;
        }
        ps[4].innerHTML = `<a href="https://tree-map.nycgovparks.org/#treeinfo-${ps[4].innerHTML}" title="view this tree in NYC Street Tree Map" target="_blank">${ps[4].innerHTML}</a>`
        titles.forEach((title, j) => {
            if (title) {
                ps[j].innerHTML = "<strong>" + title + ":</strong> " + ps[j].innerHTML;
            }
        });
        ps[6].innerHTML = `${ps[6].innerHTML} inches`;
    }
}